Date,Advisory,Patch commit(s),Affected by CHERI kernel,,,,,,,Can unpatch?,Local / Remote,Overflow,DoS,Exec,Disclosure,"Corrupt
Memory",Not memory safety bug,"Arch
Specific",UaF (UMA/kmalloc),"Race or
TOCTTOU",Priv Escalation,Affects network stack,NULL ptr dereference,NOTES,History
,,,PTR provenance,PTR integrity,Bounds Checking,PTR perms,Temporal,Subobject,Does not help,,,,,,,,,,,,,,,,
2022-08-09,FreeBSD-SA-22:11.vm,5c50e900ad779fccbf0a230bfb6a68a3e93ccf60,,,,,,,X,,local,,,,X,,X,,,,X,,,"vm_fault_copy_entry() fails to remove other existing mappings in the same conditions as SA-21:08. Under the same conditions vm_fault_copy_entry() fails to remove other processes mappings, leading to memory disclosure.",
2022-08-09,FreeBSD-SA-22:10.aio,45c2c7c484de7747014492b17ff89e323ee66496,,,,,T,,T,,local,,,,,,,,X,,,,,Failure path in aio_aqueue() leads to ucred structure reference count leak. This can be used to overflow the ucred reference count and cause an use-after-free. The ucred is kmalloc allocated. CHERI temporal safety may help with avoiding memory reuse.,
2022-08-09,FreeBSD-SA-22:09.elf,00d17cf342cd9f4f8fd1dcd79c8caec359145532,,,X,,,X,,,local,X,X,,,,,,,,,,,Core dump logic does not correctly handle sbuf with length 0 or -1 from proc_getargv(). I believe that the unhandled -1 case would cause an unbounded kernel read in memchr overflowing the psinfo->pr_psargs buffer. In this case CHERI subobject bounds would also apply.,
2022-04-06,FreeBSD-SA-22:08.zlib,zlib.patch 5c44459c3b28a9bd3283aaceab7c615f8020c531 4346a16853e19b45787ce933666026903fb8f3f8,,,,,,,X,Probably hard,local,X,X,,,X,,,,,,,,"Reported originally in zlib CVE-2018-25032, it was re-evaluated in 2022. Zlib is used in some kernel modules and by the ELF loader. There is an overflow in zlib that appears to involve a buffer that is shared among different data. The same malloc allocation is used for different buffers, invalid arithmetic manipulation can result into memory corruption into the other internal buffer. There is no indication that the overflow may go beyond the allocated buffer, so CHERI does not help in this case. Sub-object bounds can not help because the buffers are shared manually using pointer arithmetic, without ever taking a sub-allocation pointer that can be bounded by the compiler. There is no indication that this may cause a kernel code exec, as the corrupted buffer should not contain pointers. Discussed here, here, here and here",
2022-04-06,FreeBSD-SA-22:07.wifi_meshid,fb8c87b4f3bfdfac014f9d894fe75fbad0391b24,,,X,,,,,Easy,remote,X,,X,,X,,,,,,X,,The ieee80211_parse_beacon() fails to validate the mesh ID length. The sta_add() function should be called to process the beacons from the scan. Here the meshid is copied to a fixed-length buffer in `struct sta_entry` in the parent `struct ieee80211_scan_entry.se_meshid`. The `struct sta_entry` comes-from kernel malloc. This leads to unbounded kernel memory write. CHERI protects from this.,
2022-04-06,FreeBSD-SA-22:06.ioctl,8276c4149b5fc7c755d6b244fbbf6dae1939f087,,,X,,,,,,local,X,,,,X,,,,,,,,"The mpr, mps and mpt drivers contain errors in handling *_CFG_PAGE IOCTLs. A buffer with user-controlled size is then used as target of a fixed-size copyin(), leading to possible overflow of kmalloc buffer. E.g. MPRIO_READ_CFG_PAGE allocated the user-controlled mpr_page buffer with user-controlled length. The ioctl handler then proceeds to copy sizeof(MPI2_CONFIG_PAGE_HEADER) bytes into it, leading to a potential overflow.",
2022-04-06,FreeBSD-SA-22:04.netmap CVE-2022-23084,393729916564ed13f966e09129a24e6931898d12,,,X,,,,,Easy,local,X,,,,X,,,,X,,X,,Total size of nmreq is computed and then trusted for the copyin() in nmreq_copyin(). This is a time-of-check-to-time-of-use error as the user may change the nmreq structure leading to kernel memory corruption via overflow of the allocated buffers. CHERI would not remove the TOCTTOU but mitigate the overflow.,
2022-04-06,FreeBSD-SA-22:04.netmap CVE-2022-23085,694ea59c7021c25417e6d516362d2f59b4e2c343,,,X,,,,,,local,X,,,,X,,,,,,X,,"User controller integers in nmreq_copyin() are used to compute buffer sizes without checking whether they would overflow. Integer overflow of optsz and bufsz could result in buffers too small for the requested operation, overflowing kernel-malloc memory via copyin(). CHERI stops this.",
2022-03-15,FreeBSD-SA-22:02.wifi CVE-2020-26144,ffc19cf52da5546973965f78cf32aa0f2c9657f8,,,,,,,X,,remote,,,,,,X,,,,?,X,,Prevent plaintext injection via A-MSDU EAPOL frames. This does not seem to involve CHERI.,
2022-03-15,FreeBSD-SA-22:02.wifi CVE-2020-24588,f024bdf1155f36d2d8c4caa533b66e4040c4c469,,,,,,,X,,remote,,,,,,X,,,,?,X,,Prevent A-MSDU aggregation attacks. This does not seem to involve CHERI.,
2022-03-15,FreeBSD-SA-22:02.wifi CVE-2020-26147,11572d7d7fb9802ceb46ea9dc6cbe3bb95373e55,,,,,,,X,,remote,,,,?,,X,,,,,X,,Prevent mixing of plaintext/encrypted fragments. This does not seem to involve CHERI.,
2022-01-11,FreeBSD-SA-22:01.vt,dbc7ca59451561a179f9852642e13ef024169d84,,,X,,,,,Feasible,local,X,,,,X,,,,,,,,Failure to enforce bounds when redrawing the screen involving scrolling and highlighted text in the vt driver results in overflow of the `struct vt_device` `vd_drawn` `vd_drawnfg` and `vd_drawnbg` buffers. These buffers are statically allocated and should be bounded in CHERI.,
2021-05-26,FreeBSD-SA-21:11.smap,91aae953cb807d6fb7a70782b323bf9beb60d7c9,,,,,,,X,,local,,,,,,X,amd64,,,,,,"Fault handling during copyin/out fails to correctly handle Supervisor Mode Access Prevention (SMAP), leaving it disabled if the fault is invalid. This results in running kernel code handling the error from copyin/out with SMAP disabled which may be chained with other errors to exploit the kernel.",
2021-04-06,FreeBSD-SA-21:10.jail_mount,2425f5e9128102c8e6e473567ad6759a55be5b02,,,,,,,X,,local,,,,,,X,,,,X,,,"A jailed process can race the lookup for '..' to mount over the jail root filesystem, leading to access to filesystem outside the jail. Not sure how this is triggered exactly but it is a race unrelated to memory safety.",
2021-04-06,FreeBSD-SA-21:09.accept_filter,653a437c04440495cd8e7712c7cf39444f26f1ee,,,,,T,,T,Easy,local,,,,,,,,double free,,,X,,"If an accept filter is configured on a socket and the accept filter supports the accf_create callback, the filter name parameter is preserved in `struct socket.sol_accept_filter_str`. The accept_filter_str buffer is freed immediately after leaving a dangling pointer in sol_accept_filter_str. This leads to use-after-free of the string buffer from kmalloc or potentially a double-free.",
2021-04-06,FreeBSD-SA-21:08.vm,982693bb729badac4e65ecd59772979f2849a2b2,,,,,,,X,Feasible,local,,,,X,,X,,,,X,,,"It might be possible that multiple processes share a mapping of read/write pages shadowing pages from a common ancestor process. In this situation, if one of these processes modifies memory in the mapping, the CoW logic fails to invalidate all the other mappings of the source page in the other address spaces. This results in the source page remaining accessible to the other processes even after the source page is deallocated and reused by other processes or the kernel. CHERI does not help here because it is a page handling error.",2021-04-13: Added KASAN kernel option
2021-02-24,FreeBSD-SA-21:06.xen,808d4aad1022a2a33d222663b0c9badde30b9d45,,,,,,,X,,local,,X,,,,X,,,,,,,Xen grants allow shared memory operations across domains. Grant mappings are generally done in batch hypercalls. The FreeBSD backend driver mishandles grant mapping requests in batch operations. This may result in resource leaks as some successfully mapped grant requests get lost and can no longer be unmapped.,
2021-02-24,FreeBSD-SA-21:05.jail_chdir,d4380c0cdd0517dc038403dd5c99242ce78bdeb5,,,,,,,X,,local,,,,,,X,,,X,X,,,A process such as jexec or killall attaches to a jail using jail_attach(). An oversight in jail_attach() relies on the caller to ensure that the current working directory is inside the jail. A jailed root process may race to attach to the jail-entering process via ptrace and gain access to directories outside the jail.,
2021-02-24,FreeBSD-SA-21:04.jail_remove,cc7b73065302005ebc4a19503188c8d6d5eb923d,,,,,,,X,,local,,,,,,X,,,X,X,,,Race condition in jail_remove() may lead to the syscall failing to kill all jailed processes in the target jail. A privileged process that escapes termination in this way may race to access devfs nodes unrestricted if a new jail is created with the same root path. This occurs because there will be a window between devfs being mounted into the jail and the jail ruleset being applied to the jailed devfs. A process may escape the jail by racing to fork() while jail_remove() attempts to kill the jail.,
2021-01-29,FreeBSD-SA-21:02.xenoom,4e4e43dc9e1afc863670a031cc5cc75eb5e668d6,,,,,,,X,,local,,X,,,,X,,,,,,,"A guest can run the xen backend out of memory by spamming watch events, which are handled by FreeBSD from a single thread and queued while waiting for the thread to handle the event.",
2021-01-29,FreeBSD-SA-21:01.fsdisclosure,599f90446376370eb365a0fde857ea2b5766873a,,,,,,,X,Easy,local,,,,X,,,,,,,,,Uninitialized bytes in the dirent structure are not cleared in msdosfs. This leads to a leak of uninitialized kernel data via VOP_READDIR. CHERI does not help because this involves inner struct padding.,
2020-12-01,FreeBSD-SA-20:31.icmp6,d9999ae9ca1d022bfac4d8834ce9a9e7929bbdae,,,,,T,,T,,remote,,,,,,,,X,,,X,,icmp6_notify_error() handles routing options (IPPROTO_ROUTING) and potentially extracts a pointer into the mbuf to the destination in6_addr. The options memory may be freed at a later point but the pointer is then used in the `struct ip6cltparam` which is later processed. The free may occur due to m_pullup from a fragment ext header or within the next protocol pr_ctlinput (this does not seem to occur in practice but the pointer to the final destination address is unstable). CHERI can likely do something for UMA UaF.,
2020-09-15,FreeBSD-SA-20:29.bhyve_svm,101d5b527a5274b44c1354f9c6a31960e7007a69,,,,,,,X,,local,,,,,X,X,amd64,,,X,,,"Bhyve does not intercept some guest instructions that bypass nested page table translation, allowing a guest to take control of the host address space.",
2020-09-15,FreeBSD-SA-20:28.bhyve_vmcs,09860d44e4f52ea4b77051fb988bcffa221d0a59,,,,,,,X,,local,,,X,,,X,amd64,,,X,,,Incorrectly expose VMCB /VMCS fields for write access to root/jailed users breaks bhyve.,
2020-09-15,FreeBSD-SA-20:27.ure,0b39e3448aeace003ccdbcc54a32662e673c3131,,,,,,,X,,remote,,,,,,X,,,,X,,,"Error in handling packets in ure USB driver erroneously cap packet size at 2048 bytes within a single USB transfer, even though the actual transfer size is larger than 2048 bytes. This causes a single large packet to be interpreted as multiple packets. CHERI doees not seem to help with this issue.",
2020-09-02,FreeBSD-SA-20:25.sctp,f5d30f7f76067fa53901af94d92f27781d911521,,,,,T,,T,,local,,,,,,,,X,,,X,,UaF triggered by sending a large message from 2 threads on the same socket. ,
2020-09-02,FreeBSD-SA-20:24.ipv6,e7a541b0b99622dcce21fb087da016a948fcbb60,,,,,T,,T,,local,,X,,,,,,mbuf,,,X,,Hop-by-Hop IPv6 options over loopback interface are not handled correctly. ip6_input_hbh() may modify the mbuf chain via m_pullup() invalidating old pointers via ip6_hopopts_input(). This would result in ip6_input() (the original caller of ip6_input_hbh()) to use a stale pointer for the mbuf data. CHERI temporal safety might help catching this but the stale data in ip6_input() may remain a probelm.,
2020-08-05,FreeBSD-SA-20:23.sendmsg,1b1428dcc82b54b7a2c332680d2f66945bf9899b,X,X,X,,,,,,local,X,,,,X,,,,X,X,,,"The sendmsg() control message header handling code in compat32 contains a TOCTTOU with respect to the control message header size validation. This allows userspace to modify the control message headers after the kernel has validated the lengths but before the data is copied into kernel space. The space for the data is allocated in an mbuf, but the space is assumed to be enough for the copies. If the user races the kernel check by changing the cmsghdr length after the initial check, it is possible to construct a message header with an arbitrary length to overflow the allocated mbuf buffer and corrupt arbitrary kernel memory. CHERI stops the overflow.",
2020-08-05,FreeBSD-SA-20:21.usb_net,9c847ffd743b4f68af56c5069da401bd1831efcb,X,,X,,,,,,local,X,,X,,X,,,,,,X,,"Missing length checks in USB network device drivers may lead to code execution by writing past a network packet buffer. In the cdceem driver, the pktlen provided by the USB device is not checked agains the mbuf obtained via uether_newbuf() which has a fixed length. The following usbd_copy_out() attempts to copy pktlen bytes into the mbuf, leading to a possibly device-controlled unbounded write into kernel memory. CHERI prevents this because mbuf buffers are bounded. Note that it would also be impossible to inject pointers into the overflowing area because the device can not forge kernel (or user) pointers.",
2020-07-08,FreeBSD-SA-20:20.ipv6,e02582d1ae44dfc7ae009481ce12930ccf662142,,,,,T,,T,,local,,,,,,,,X,X,,X,,Missing locking in handling of IPV6_2292PKTOPTIONS in ip6_ctloutput() allows concurrent operations on inpcb.in6p_outputopts while ip6_pcbopts() could free() some of the options. This leads to kmalloc use-after-free.,
2020-06-09,FreeBSD-SA-20:17.usb,eff815491349029cf24182bfa58613d665b3123e,,,X,,,X,,Easy,local,X,,X,,X,,,,,,,,"USB descriptor level push/pop is not correctly restored. This may allow a physical attacker to gain kernel code execution. It seems that the pushlevel is used as an index into `struct hid_data.cur` array. The pushlevel check is performed AFTER the increment/decrement, this allows malicious HID reports to increase pushlevel past MAXPUSH. A second call to hid_get_item_raw() would then initialize `c` (i.e. the current state pointer) blindly from the current pushlevel, causing it to overflow the `struct hid_data.hid_item_cur`. CHERI stops this with bounds check on the hid_data object. Subobject bounds prevent overflow within the hid_data struct.",
2020-05-12,FreeBSD-SA-20:16.cryptodev,5ac518b51fdc6d1baeb2605d19b04848fc29dcbe,,,X,,,,,,local,X,,,,local,,,,,,,,Incomplete checking of MAC key length in CIOCGSESSION. This results in allocation of cryptoini.cri_key via kernel malloc of possibly undersized key. This will lead to overflow in the cri_key buffer on copyin(). CHERI prevents this as kernel malloc allocations are bounded.,
2020-05-12,FreeBSD-SA-20:15.cryptodev,d2cdaed130a9d63c1fe0a66d9d22a11d806472a4,,,,,T,,T,,local,,,,,X,,,X,X,,,,"CIOCFSESSION and crypto requests use-after-free races in cryptodev. This is due to missing lock and refcount management in csefind and csedelete. This allows a race to free() the session `struct fcrypt` while another thread is also attempting to use it. CHERI temporal safety may help with quarantining memory before reuse, however it does not remove the locking issues.",
2020-05-12,FreeBSD-SA-20:14.sctp,3c193115440ea21d7811c20326488be4346ed4a2,,,,,T,,T,,local,,,,,,,,kmalloc,,,X,,"Insufficient checking allows an user application to trigger an SCTP auth shared key update when the key is marked as deactivated, leading to an use-after-free. This may occur when the refcount for the key is > 1 as the check is bypassed. The old skey can then be free'd before the refcount reaches 0. SCTP keys are allocated via kernel malloc.",
2020-04-21,FreeBSD-SA-20:10.ipfw (oob access),1ae74c1359d2d081e8076f8421e520a9f4ddb863,,,X,,,,,,remote,X,,,,,,,,,,X,,Out-of-bounds mbuf access due to incomplete TCP options parsing in ipfw tcpopts_parse(). The optlen value is not validated and could allow to read past the end of the mbuf. This seems to be limited by the width of the cp[] byte array to 255.,
2020-04-21,FreeBSD-SA-20:10.ipfw (use-after-free),ca0ac0a6c1aa96aaa88fc360aead02043d3dadc2 d4e6a529595dc4ace5be06a3fe9db4e05ebfd4eb f355cb3e6fa1dea72938b83d5b69a99bc4e1fe0c,,,,,T,,T,,remote,,,,,,,,X,,,X,,"In ipfw_chk() PULLUP_LEN_LOCKED performs an m_pullup() on the given mbuf chain. This may invalidate existing pointers, specifically the pointer to the IP header cached in `ip`. This is relevant in the loop that scans through the rule chain and performs matching and processing. O_TCPOPTS and O_TCPMSS use PULLUP_LEN_LOCKED but forget to UPDATE_POINTERS(). This means that the ip pointer may be invalid for the rest of the rules in the chain, for example if O_LOG, O_REJECT, O_UNREACH, O_SETDSCP, O_REASS are found afterwards we may either leak or corrupt free'd memory. CHERI temporal safety may help, this is memory from the mbuf UMA zones.",
2020-03-19,FreeBSD-SA-20:08.jail,1b786d01917ccd90f4b2fffab8e735a25707e63d,,,X,,,X,,Feasible,local,local,,,local,local,,,,,,,,"Missing \0 terminator in user-supplied string via osrelease parameter in kern_jail_set() may lead to reading past the end of a buffer, disclosing arbitrary kernel memory. The osrelstr pointer holding the value from the osrelease parameter is fed to a plain strcpy(), this will cause 2 things to occur: [1] The osrelstr buffer will overflow-read into arbitrary kernel memory. [2] The prison.pr_osrelease buffer may overflow-write depending on where the first zero byte is found from osrelstr. CHERI will stop both occurrences, where (2) is mitigated by subobject bounds preventing an overflow into the prison struct.",
2020-03-19,FreeBSD-SA-20:07.epair,b02fd8b79028c01715e168a25d0fd86ff09b9ce3,X,X,,,,,,Annoying to unplumb but maybe feasible,local,,,X,,X,,,,,,X,,"An user-controlled pointer is passed to if_clone_createif(), leading to memory corruption or kernel code execution. The if_clone_create() is triggered by an ifioctl SIOCIFCREATE2. Such call uses the ifr_data_get_ptr(ifr) using the ioctl input `struct ifreq` data as the param argument to the if_clone_create(), this is user controlled. if_clone_create() forwards params to if_clone_createif(). The latter uses the ifc_create() function of the interface cloner (namely epair_clone_create()). The epair_clone_create() needs to create the two paired ETH interfaces: the first is created normally, the second is created using a recursive call to if_clone_create() with the `struct epair_softc` as the param argument. When the second epair_clone_create() call is serviced, the params argument is assumed to be the epair_softc and used accordingly. The userland can then control the location in memory of the assumed epair_softc. CHERI prevents this to be a kernel pointer.",
2020-03-19,FreeBSD-SA-20:06.if_ixl_ioctl,ab43ce7a22690b66cf76f0d8e70d538442657077,,,,,,,X,,local,,,,,,X,,,,X,,,Insufficient privilege checking for ixl ioctl.,
2020-03-19,FreeBSD-SA-20:05.if_oce_ioctl,c76ddeeb1c32e72a73f5f9ba89dd39dee596a5ac,,,,,,,X,,local,,,,,,X,,,,X,,,Insufficient privilege checking for oce ioctl. ,
2020-03-19,FreeBSD-SA-20:04.tcp,6605e5791f7667abf3e8cd02cbc9b7533f816887,,,,,,,X,,remote,,,,X,,,,,,,X,,uninitialized field in IPv6 header leads to leak of uninitialized UMA mbuf_zone kernel memory via the IPv6 traffic class field. CHERI does not help because this involves inner struct data.,
2020-01-28,FreeBSD-SA-20:03.thrmisc,2e5f9189bb92b6f77ed7ac4608a058e69e2b5bee,,,,,,,X,,local,,,,kstack,,,,,,,,,"elfN_note_thrmisc() fails to properly zero the thrmisc struct before copyout, leaking uninitialized kernel stack bytes. CHERI does not fix this because it involves inner struct padding.",
2020-01-28,FreeBSD-SA-20:02.ipsec,d5f39c34a64b8d2ffc17e218c89e0fb52e624097,,,,,,,X,,remote,,,,,,X,,,,,X,,Ipsec allows to inject old packets successfully.,
2019-11-12,FreeBSD-SA-19:25.mcepsc,c08973d09c95f7459bedf22fe212beb3f5107227,,,,,,,X,,local,,X,,,,X,amd64,,,,,,Intel Machine Check Exception DoS,
2019-08-20,FreeBSD-SA-19:24.mqueuefs,f37192064a44f28d1b1c6dfe311ad8a0d45aed89,,,,,T,,T,,local,,,,,,,,X,,,,,Reference count overflow in compat32 mqueue. An error condition on copyin() fails to release a file descriptor reference count. This can lead to wrapping and use-after-free. CHERI temporal safety should be able to help,
2019-08-20,FreeBSD-SA-19:23.midi,35fd0fc40918d04d5d86573839ff2f36dd780545,,,X,,,,,,local,,,,X,,,,,X,,,,The midistat driver implements a read() handler that is not thread-safe. midistat_read() needs to release the midistat_lock when douing uiomove of sbuf data beacuse the lock is not sleepable. This gives the opportunity for races that modify either the midistat_sbuf or midistat_bufptr (which are global) to potentially access past the sbuf data. CHERI should stop this as sbuf are bounded.,
2019-08-20,FreeBSD-SA-19:22.mbuf,afd959f33292cb63aa784c221e5f62add2b21eed,,X,X,,,,,"Easy, exploitable",remote,X,X,,X,X,,,,,,X,,"Missing check in m_pulldown may result in non-contiguous data. This occurs when the following conditions are met: (1) mbuf is writable (2) pulldown data is split between 3 mbufs (3) the middle mbuf has enough leading space to accomodate hlen data, i.e. all the data that we need to move from the first mbuf. Under these conditions, m_pulldown only moves the data from the first to the middle mbuf but leaves the trailing data split between the middle and last mbufs. This can result in overflow or corruption past the middle mbuf m_data. The actual impact depends on whether we can set up the conditions for this but may affect everything from network stack to IPC sockets. CHERI protects from the overflow as mbuf data buffers are bounded.",
2019-08-06,FreeBSD-SA-19:19.mldv2,7f8c266da570727b937c70054dd07592e29ae762,,,X,,,,,,remote,X,,,X,X,,,,,,X,,"ICMPv6 fails to handle MLDv2 listener query packet that is fragmented across multiple mbufs. The mldv2_query struct is assumed to be within the same mbuf, and is fetched using a plain mtod() instead of properly handling fragmentation with m_pulldown(). CHERI should prevent this as mbuf data is bounded.",
2019-07-24,FreeBSD-SA-19:17.fd,47c3450e50ae3a2a23b74929c3455c424e02809e,,,,,T,,T,Doable but not straightforward,local,,,,,,,,X,,,,,Transmitting rights through a UNIX socket (SCM_RIGHTS) may result in leakage of a file descriptor refcount if some other control message fails to process later (the cleanup fails to release the filedescend and file references). This could lead to file descriptor refcount wrap-around and related vulnerablities of use-after-free.,
2019-07-24,FreeBSD-SA-19:15.mqueuefs,f37192064a44f28d1b1c6dfe311ad8a0d45aed89 051e692a998c47d6c7cef762a32e81ff96a98bd2,,,,,T,,T,,local,,,,,,,,X,,,,,Reference count for the file descriptor can be overflowed because of a missing fdrop in an error handling path in kmq_timedsend() and kmq_timedreceive() (and freebsd32 variants). The file descriptor may then be reallocated. CHERI temporal safety with a quarantine in UMA and kernel malloc should help.,
2019-07-24,FreeBSD-SA-19:14.freebsd32,freebsd32.patch b7edb6fa77fc1ae8a5ff828b14121a5c8330a8a4,,,,,,,X,,local,,,,X,,,,,,,,,Kernel memory disclosure via compat32 ioctl because of missing zeroing of stack-allocated structures. CHERI does not help with this as it involves inner structure uninitialized space. The commit appears to independently fix the issue although the patch is not replicated anywhere in the source tree. I am not convinced that the issue is actually fixed in HEAD as the new implementation appears to leak M_TEMP malloc memory instead of kernel stack as there is no M_ZERO.,
2019-07-24,FreeBSD-SA-19:13.pts,6a01874c5afaac9d1f5f18827a6084c7056c07b6,,,,,T,,T,Feasible,local,,,,,X,,,X,,,,,Write-after-free in pts as funsetown() is not called for some descriptors associated with a tty. We get memory corruption if the descriptor is closed before the owner exits although it is not clear to me how this would occur exactly. This might occur via ptsdev_close() -> tty_rel_gone() -> tty_rel_leave() which originally does not call funsetown(). This probably means that SIGIO can still be delivered if the owner does not exit().,
2019-07-02,FreeBSD-SA-19:11.cd_ioctl,fc795c25d40545d022b5e3d2918ae480aeb765a1,X,X,,,,,,Feasible,local,,,,,X,,,,,X,,,"The linux compat CDIOCREADSUBCHANNEL_SYSSPACE was erroneusly exposed to userland. This allows to bypass a copyout for a bcopy, potentially allowing a write to an arbitrary kernel address. CHERI would have prevented this as the userland is unable to forge kernel pointers.",
2019-07-02,FreeBSD-SA-19:10.ufs,ab2214d40049c75a1516d769ce7730e357f6ea62 0061238fb0365ac840d1e039f2391ed24fcad2d1,,,,,,,X,,local,,,,kstack,,,,,,,,,"Uninitialized padding from kernel stack allocations in ufs_makedirentry() is written to disk, which can then be read from unprivileged users. This happens via the newdirp pointer, which is stack-allocated in the caller. The d_name buffer trailing padding must be zeroed. CHERI does not help because this is inner structure padding.",
2019-06-19,FreeBSD-SA-19:08.rack,5e02b277a4fac9fa5046d81e7cb9a5df54e25895,,,,,,,X,,remote,,X,,,,X,,,,,X,,TCP RACK (Recent-ACK) packet loss detection algorithm can lead to DoS due to CPU usage or memory exhaustion to traverse and maintain linked lists that hold RACK state.,
2019-05-14,FreeBSD-SA-19:07.mds,7355a02bdd81c788f1ff51c4089f5d9435543614,,,,,,,X,,local,,,,,,X,amd64,,,X,,,Fix MDS (microarchitectural data sampling) side channels,
2019-05-14,FreeBSD-SA-19:06.pf,64af73aadea59c22daf168ff742e8e9f03d2da78,,,,,,,X,,remote,,,,,,X,,,,X,,,Missing packet filtering checks allow rule bypass.,
2019-05-14,FreeBSD-SA-19:05.pf,6f4909de5feffdaca01782ad12938f6d95d633ae,,,X,,,,X,,remote,,X,,,X,,,,,,,,"Invalid processing of ipv6 fragment reassembly logic can lead to kernel panic. The ipv6 extension offset used comes from the last received packet instead of the first one. Crafted IPv6 packets may lead to a wrong extoff being stored in the packet PF_REASSEMBLED tag (struct pf_fragment_tag). The second issue is that the next protocol ID is taken from the first fragment header and stored into the `next` field of the last extension header. This however will not be stored at the correct location because extoff is from the wrong packet, instead it will potentially corrupt the current packet content if the number of extension headers in the first and current fragments is different. The packet corruption offset will depend on the different number of extension headers. Note that this will also affect pf_refragment6() as it uses the wrong offset from the mtag, but impact here seems limited. CHERI should stop any potential mbuf overflow however it may still be possible to corrupt packets to bypass filtering or other undefined behaviour.",
2019-02-05,FreeBSD-SA-19:02.fd,401ca034cdb6cc418a461ce70ab28f92d83d51fb,,,,,T,,T,Simple,local,,,,,,,,multiple,,X,,,"Failure to release a file descriptor reference when a file descriptor is passed via a UNIX socket but the receiver does not provide a large enough buffer. This may lead to reference count wrap-around and subsequent free of the file structure. If the file structure is reallocated and reused this may lead to privilege escalation. Note that there are multiple allocators involved: the file structure is allocated via UMA, however other nested objects such as credentials come from kernel malloc and may be subject to reuse from other subsystems leading to a user-controllable buffer.",
2019-02-05,FreeBSD-SA-19:01.syscall,762138f78f0661ae77b7913a28b69d01f7c69b2a,,,,,,,X,,local,,,,,,X,amd64,,,X,,,Leak of kernel register via syscall instruction because callee-save registers are not handled correctly,
2018-09-12,FreeBSD-SA-18:12.elf,c9e562b188682eb9be39a8124893aa172b57d3ca,,,,,,,?,,local,,X,,X,,,,,,,,,"Missing ELF validation results of execution of potentially malicious ELF. The issue is caused by a malformed PT_INTERP entry, with the p_filesz < 2 and a malformed p_offset. Note that p_offset is unsigned in the ELF but gets cast to a signed integer in vn_rdwr. The code path that does not perform vn_rdrw should possibly crash the kernel if p_filesz is manipulated so that the path string crossing into the next page is not detected, this will likely a segfault. The kernel memory disclosure is unclear to me, as the limitation of < 2. CHERI may help with the disclousure but this is unknown, so leave it for now.",
2018-08-14,FreeBSD-SA-18:10.ip,2ceeacbe711f3719cf7b95296627fa766956503e,,,,,,,X,,remote,,X,,,,X,,,,,X,,Resource exhaustion during IP reassembly. This can lead to CPU overload or mbuf cluster exhaustion.,
2018-08-14,FreeBSD-SA-18:09.l1tf,9840c7373c0d02ff9b490bb597a081fca5fcc750,,,,,,,X,,local,,X,,,,X,amd64,,,,,,amd64 L1 Terminal Fault side channel mitigation,
2018-08-06,FreeBSD-SA-18:08.tcp,95a914f6316874f5b0c45d491f2843dc810071ef,,,,,,,X,,remote,,X,,,,X,,,,,X,,TCP reassembly of segments can lead to CPU overload.,
2018-06-21,FreeBSD-SA-18:07.lazyfpu,fc3e80c322e7b6ee8bb7abdb8c4be23a062c1ccc,,,,,,,X,,local,,,,,,X,i386/amd64,,,,,,Speculative side channel via FPU state.,
2018-05-08,FreeBSD-SA-18:06.debugreg,053641bb1cef4431983c2ce81e605520fa0380e2,,,,,,,X,,local,,,,X,,X,amd64,,,X,,,"Invalid handling of mov/pop ss instructions when a debug exception occurs, leading to handling the exception within the kernel context.",
2018-04-04,FreeBSD-SA-18:05.ipsec (pointer/offset mistakes),b12a7532e390d7d3542b3b6d758f5c4d226c9fd2,,,,,,,X,,remote,,X,,,,X,,,,,X,,Invalid offsetting within the mbuf data.,
2018-04-04,FreeBSD-SA-18:05.ipsec (triggerable buffer overflow),055679e67e139c132e2928466f84c2e085bf1f16,,,X,,,,,,remote,X,,,,X,,,,,,X,,"Write extra zeros past the end of an mbuf when processing ipv6 packets. This happens because the loop that processes ipv6 headers fails to correctly increment the buffer offset. The increment does not add the size of the option header (2 bytes), which in theory means that option headers can be manipulated to cause a malformed count and cause a bzero past the mbuf m_data end. CHERI should stop this as mbuf data is bounded.",
2018-04-04,FreeBSD-SA-18:05.ipsec (infinite loop),055679e67e139c132e2928466f84c2e085bf1f16,,,,,,,X,,remote,,X,,,,X,,,,,X,,Incorrect handling when loop length is zero leads to infinite loop.,
2018-04-04,FreeBSD-SA-18:04.vt,9f6fffc7312725f767237797fffa596826fa36d9,,,X,,,,,,local,X,,,X,,,,,,,,,"VT console disclosure due to integer overflow in glyphsize when processing font data in vtfont_load(). Arbitrary kernel memory is used as glyph data leading to a leak. This occurs when the glyphcount manages to overflow size_t, so that the glyph buffer is actually shorter than requested, leading to kmalloc overflow and disclosure. CHERI should prevent this.",
2018-03-14,FreeBSD-SA-18:03.speculative_execution,bd50262f705c4fed70ea94d16a0f19b5f5497cf2,,,,,,,X,,local,,,,X,,X,amd64,,,,,,Spectre/meltdown mitigations,
2018-03-07,FreeBSD-SA-18:01.ipsec (mbuf overflow),6ca39da3548b10ddbd39cb47b50f6c594a2b1690,,,,,,,X,Feasible,remote,X,X,,,,,,,,,X,X,"ah_input() in ipsec fails to validate that the packet holds at leas the ah header and authenticator. If this is not true the packed header length will be too short and attempt to copy via m_copydata() will fail. If assertions are enabled this would panic, otherwise it will cause a NULL pointer dereference because m_copydata walks past the mbuf chain. I don't think this would cause corruption though.",
2018-03-07,FreeBSD-SA-18:01.ipsec (UaF),6ca39da3548b10ddbd39cb47b50f6c594a2b1690,,,,,T,,T,Feasible,remote,,,,,,,,X,,,X,,"ah_input() does not save the ah_nxt across ah_massage_headers, which may invalidate the ah header pointer because of m_pullup(). This results in use-after-free of the ah header, which comes from an mbuf UMA allocation.",
2017-11-15,FreeBSD-SA-17:10.kldstat,edb01d11f89618f0bfb1db67682effb1dd9fa781,,,,,,,X,,local,,,,kstack,,,,,,,,,Kernel stack disclosure via kldstat() due to insufficient zeroing of the output struct before copyout(). CHERI does not help because this involves inner struct padding.,
2017-11-15,FreeBSD-SA-17:09.shm,adb023ae59d5535b8288fb779fd6e24b96cbd8ca,,,,,,,X,,local,,,,,,X,,,,X,,,"SHM object paths are not separated across jails, leading to one jail being able to access SHM objects from another jail. This is not related to CHERI as this is a logic error in exposing shm object namespace.",
2017-11-15,FreeBSD-SA-17:08.ptrace,9acf7b136db39dafe0fd733214ae94f47c254e12,,,,,,,X,,local,,,,kstack,,,,,,,,,Missing zeroing in lwpinfo before copyout in ptrace. This leads to the disclosure of some kstack bytes. CHERI does not help because this involve inner struct padding.,2017-10-17: syzkaller FreeBSD support
2017-04-27,FreeBSD-SA-17:04.ipfilter,666bd4d2532230dee4ace395edb4c1cfea06748d,,,,,T,,T,,remote,,X,,,,,,X,,,X,,"The wrong ipfilter TCP/UDP packet fragment entry is freed from the fragment cache, leading to use after free panic.",
2016-05-31,FreeBSD-SA-16:21.43bsd,34e05ebe7281cdb7f4378339ab183e33780d801f,,,,,,,X,,local,,,,kstack,,,,,,,,,"Kernel stack disclosure due to insufficient zeroing of ioctl output struct before copyout(), CHERI does not help as the leak affects the inner struct padding.",
2016-05-31,FreeBSD-SA-16:20.linux,34e05ebe7281cdb7f4378339ab183e33780d801f,,,,,,,X,,local,,,,kstack,,,,,,,,,"Kernel stack disclosure due to insufficient zeroing of ioctl output struct before copyout(), CHERI does not help as the leak affects the inner struct padding.",
2016-05-17,FreeBSD-SA-16:19.sendmsg,7349ea785c916bbd7516077f293ae93bbb54dbbf,,,X,,,,,,local,,X,X,,,,,,,,,,"Handling in sockargs() via sendmsg() missing buflen range check. Using a crafted negative buflen it should be possible to get an mbuf via m_get2() too short to hold the copyin() of the data from userland, leading to an overflowing write into kernel memory. CHERI prevents this because mbuf data is bounded.",
2016-05-17,FreeBSD-SA-16:18.atkbd,c9d2719027821229f5ca9a5194040713c3d0409c,,,X,,,X,,Feasible,local,X,,,,X,,,,,,,,"keyboard driver buffer overflow in SETFKEY ioctl. The kb_fkeytab[fkeyp->keynum].len is set using imin() insted of min(), resulting in overflowing bcopy() into kb_fkeytab[].str. The fkeyp is the ioctl argument and is user controlled. fkeyp is a fkeyarg_t, the fkeyp.flen is a signed char, MAXFK (the maximum string length of a function key) is 16, so there is the chance for imin() to be up to negative 128. The target buffer is a fixed-length MAXFK buffer, allocation depends on the keyboard driver via kbd_set_maps(). For example atkbd either allocates the keytab statically or via kmalloc. The USB ukdb driver instead have the fkeymap embedded in the ukdb_softc. CHERI would stop this as fkeytab.str is a fixed-length string, subobject bounds help depending on implementation: the ukdb driver without subobject bounds may allow trashing of the ukdb_softc.",2016-05-27: First KASAN mention in a fix
2016-03-16,FreeBSD-SA-16:15.sysarch,e33c2e6b06128675d62db3b8fec5576a884f9865 ccd08e4d99fa607d7ad8fc0dc02329850ce24244,,,X,,,X,,,local,,,,,X,,amd64,,,,,,"amd64_set_ldt() initiated via sysarch syscall misses argument validation that leads to unbound zeroing of the process LDT and adjacent memory. This is caused by integer overflow of the largest_ld which then is used to compute the bzero() length. CHERI stops this because the pldt->ldt_base would be bounded as it comes from kmem_malloc(). CHERI subobject bounds would also help to avoid corruption of the whole LDT array, although it might still be possible to achieve the same result using repeated sysarch calls.",
2016-01-27,FreeBSD-SA-16:10.linux,669414e4fb7463aa46811636ad6b6b66834dd6fd,,,,,,,X,,local,,,,,,X,,,,X,,,Incorrect AT_SECURE value stored in auxv (and returned by glibc issetguid()) in linux compat.,
2016-01-14,FreeBSD-SA-16:05.tcp,f73d9fd2f1e7e3cdb56caf7458147db355ff0354,,,X,,,,,,remote,X,X,,,X,,,,,,X,,"Write to a random address due to tcpopt.to_signature being an uninitialized stack variable used as an offset from the tcphdr. CHERI will stop the overflow in arbitrary kernel memory but the current packet data may still be corrupted. Remote under pretty strict conditions, otherwise local.",
2016-01-14,FreeBSD-SA-16:04.linux,c8358c6e0d55601e5e81ff7829c210c64d460f85,,,X,,,,,feasible,local,,,,,X,,,,,,,,crextend() not called before copying credentials into new credentials for linux_setgroups(). This leads to a write past newcred->cr_groups[] end. CHERI should stop this as cr_groups comes from kmalloc.,
2016-01-14,FreeBSD-SA-16:03.linux,037f750877f04f57a316f597f2e0176fa1e19aab,X,X,,,,,,,local,,,,X,,,,,,X,,,"Invalid linux futex compat syscall handling results in kernel memory disclosure. The set_robust_list syscall saves the given robust list head pointer, however the get_robust_list syscall copyout() is wrong and copies back to userspace some amount of memory pointed by the head pointer. If the head is made to point to a kernel address it is possible to dump arbitrary kernel memory. CHERI stops this because it is not possible for an user process to forge a kernel pointer.",
2016-01-14,FreeBSD-SA-16:01.sctp,479795819a80a3d669f5f36903e3bbf418768f0a,,,,,,,X,,remote,,X,,,,,,,,,X,X,Panic or NULL pointer dereference due to missing SCTP input checks. This will fail in m_copydata() if the packet length is shorter than struct sctphdr.,
2015-08-25,FreeBSD-SA-15:21.amd64,2d45c2d52dfd81603621506119de8acbfbb21831 a9eb27a9900c09c60e42920a8b1da68b51550b39 f024d1a3a33280aecf362cc5d7e97f36af132d0e,,,,,,,X,,local,,,,,,X,amd64,,,X,,,Userland GS segment may be used erroneusly if a fault occurs on IRET.,
2015-07-28,FreeBSD-SA-15:15.tcp,4741bfcb57776df8564c3e4b865e5a54cda4800e,,,,,,,X,,remote,,X,,,,X,,,,,X,,Exhaustion of mbuf resources due to allocation from TCP stacks in multiple VNETs. The limit of mbuf for TCP reassembly queues is per-vnet instead of a global limit.,
2015-07-21,FreeBSD-SA-15:13.tcp,47a8e86509b258d16c4a36e2e475cb946bbc447c,,,,,,,X,,remote,,X,,,,X,,,,,X,,TCP LAST_ACK state resource exhaustion.,
2015-04-07,FreeBSD-SA-15:09.ipv6,dd3856601d978410015c4079bfdec99d0246e2a7,,,,,,,X,,remote,,X,,,,X,,,,,X,,Ipv6 neighbour discovery advertisement DoS.,
2015-02-25,FreeBSD-SA-15:04.igmp,cfa498d88e1f35d4173edaf6660bb5b1c2d49657 edc76c95db261a867bfadab30cbc3640fa33bd0c,,,X,,,,,Feasible,remote,X,X,,X,,,,,,,X,,"DoS and possible overflow in IGMP due to integer overflow in srclen variable in igmp_input(). When building the igmpv3len (uint16) for the m_pullup, the size might wrap around, resulting in the wrong m_pullup(). This would shorten the m_pullup() m_data and fail into igmp_input_v3_query as the igmpv3 pointer will point to incomplete data. The query is finally dispatched to igmp_input_v3_group_query() which will attempt to traverse the source addresses that may not have been made available via m_pullup(). This would cause a buffer overflow in the mbuf m_data and resulting potentially in kernel data disclosure, but not memory corruption.",
2015-01-27,FreeBSD-SA-15:03.sctp,6a58f0e913cac177649f9732c47fa0c3f6de9f67,,,,,,,X,,remote,,X,,,,,,,,,X,X,NULL pointer dereference due to invalid processing of SCTP RE_CONFIG chunks. It is unclear to me where the NULL dereference occurs.,
2015-01-27,FreeBSD-SA-15:02.kmem,38f2a43815f79fb4435b9d715585df49225258ae,,,X,,,,,,local,X,,,X,X,,,,,,X,,Kernel memory leak/corruption via SCTP due to missing parameter checking. The overflow should occur when the SS_VALUE optval stream_id is larger than the current association streamcount. This will result in sctp_ss_get_value() extracting data past the strmout[] array end. A similar issue occurs for setopt. It is unclear why this is limited to 16 bytes.,
2014-11-04,FreeBSD-SA-14:25.setlogin,bccb6d5aa14a143f583903dbd28512ed3e93237f,,,,,,,X,,local,,,,X,,,,,,,,,"Kernel stack disclosure via sys_setlogin(). setlogin() copies a stack allocated string buffer to the p->p_session->s_login buffer, including any unused space. sys_getlogin can then be used to retrieve the leaked stack bytes. CHERI does not help in this case.",
2014-10-21,FreeBSD-SA-14:22.namei,8cc11167fb0a602d4f9d62d4769724f81198afc,,,,,,,X,,local,,X,,,,X,,,,,,,Memory leak (missing UMA zfree) when namei fails to find a path for a sandboxed process.,
2014-09-16,FreeBSD-SA-14:19.tcp,831ad37ef267beba5b1c0f04ad34e53255fc5fb9 3220a2121cc9d20d5d8085b153ec4bffe235d600,,,,,,,X,,remote,,X,,,,X,,,,,X,,DoS due to blind SYN/RST spoofed attack,
2014-07-08,FreeBSD-SA-14:17.kmem CVE-2014-3953,e432298ade8c0f7cc2bc0969c318086dc12ce86a,,,,,,,X,,local,,,,X,,,,,,,X,,"Some SCTP messages have implicit padding that is not initialized before copyout(), leading to kernel heap disclosure.",
2014-07-08,FreeBSD-SA-14:17.kmem CVE-2014-3952,e432298ade8c0f7cc2bc0969c318086dc12ce86a,,,,,,,X,,local,,,,X,,,,,,,X,,Buffer between control msg and data not completely initialized before being copied to userland leads to kernel heap disclosure.,
2014-06-03,FreeBSD-SA-14:12.ktrace,093e059c7d8e3ce1fdf9e9237a7240b120037b05 ktrace.patch,,,X,,,X,,,local,,,,X,,,,,,,,,Size of page fault trace entries was not set correctly. An user may be able to access leaked kernel memory via process tracing with ktrace. CHERI stops this on multiple levels. Subobject bounds should stop leak out of the ktr_request.ktr_data union field. Capability bounds should stop leaking past the end of a ktr_request.,
2014-04-30,FreeBSD-SA-14:08.tcp,c6f70658c313c9443f04cb526c187817ecb82dca,,,,,?,,X,,remote,,X,,X,?,,,kernel stack in queue,,,X,,"When V_tcp_reass_zone is exhausted, a stack-allocated TCP reassembly queue entry may be added to the reassembly queue. This leads to a stack use-after-free. CHERI does not seem to help in this case. Temporal safety on the stack is a question.",
2014-04-08,FreeBSD-SA-14:05.nfsserver,25bfde79d6dacb75c66732b4ad4b14d71e0c43d2,,,,,,,X,,remote,,X,,,,X,,,,,X,,NFS server deadlock,
2013-09-10,FreeBSD-SA-13:13.nullfs,1a05c762b9c203dec97fc053448eab98b525b088,,,,,,,X,,local,,,,,,X,,,,X,,,vop_link for nullfs missing check allows write-access to files that are nominally on a readonly filesystem.,
2013-09-10,FreeBSD-SA-13:12.ifioctl,1a05c762b9c203dec97fc053448eab98b525b088,X,X,,,,,,,local,,X,?,,X,,,,,X,,,Missing validation of some ioctl at the network-layer that are propagated to link-layer drivers. Drivers assume that input has been validated and misuse the values. At minimum this seems to be used to dereference an invalid pointer and crash. Not sure how we can get abritrary code exec. CHERI can only help if the userland is attempting to inject pointers.,
2013-09-10,FreeBSD-SA-13:11.sendfile,1a05c762b9c203dec97fc053448eab98b525b088,,,,,,,X,Feasible,remote,,,,X,,,,,,,X,,"Leak of kernel memory up to the next page boundary or sendfile() userland-provided size, when the file on disk is smaller than the user-provided size. CHERI does not help because sendfile() operates on vm_page entries provided by vm_page_grab(), the sf_buf buffer is only bounded to page-size and is not enough to stop the leak of bytes past the end of the file.",
2013-08-22,FreeBSD-SA-13:10.sctp,0e05fbded989dbae569fd3a6dc6f0aad3b79cc7d,,,,,,,X,,remote,,,,X,,,,,,,X,,Missing zeroing leads to leak of uninitialized kernel memory via the sctp_state_cookie.,
2013-08-22,FreeBSD-SA-13:09.ip_multicast,acde2476c4c9fd94d8d9ac0c79d355ef24e6a6c6,,,X,,,,,,local,kmalloc,,,X,X,,,,,,X,,Integer overflow in computig size of a temporary buffer in inp_get_source_filters() results in kmalloc buffer overflow. The buffer is also copied to the userland via copyout,
2013-07-26,FreeBSD-SA-13:08.nfsserver,f1c4014cd5a19a9e894e69adbc89456a70396075,,,,,,,X,,remote,,,,,,X,,,,X,X,,Insufficient checks in NFS server can allow user to mount as privileged user.,
2013-06-18,FreeBSD-SA-13:06.mmap,5b3e02570aad765ee54aa9ba564aa97f52101227,,,,,,,X,,local,,,,,X,,,,,X,,,Missing checks in mmap allow a process with access to another process address space to write-map pages that are readonly in the traced process. CHERI does not help because this happens via legitimately mapped pages.,
2013-04-29,FreeBSD-SA-13:05.nfsserver,c93c82f464863400532af34d4ae5012145685097,,,?,,,,?,,remote,kmalloc,,,,,,,,,,X,,"NFS server does not validate that READDIR commands operate on a directory node. If this is not the case, the impact depends on the amount of validation the underlying filesystem performs. UFS may be able to trigger a kmalloc buffer overflow in vop_readdir() -> vop_read(), this would be stopped by CHERI. I am unsure how the ZFS kernel stack arbitrary access would happen.",
2012-11-22,FreeBSD-SA-12:08.linux,43f13bea35296bc14198f6cf0e5a67e556c43f5b,X,X,,,,,,,local,,,?,,X,,,,,,,,"Invalid handling of linux compat ioctl ifconf with missing copyout, using direct copy instead. CHERI stops the attack because the userland can not forge a kernel address that would lead to kernel memory corruption.",
2012-06-12,FreeBSD-SA-12:04.sysret,b0a576ce8eeaebe60d4f41aaef6297d21b3e9a31,,,,,,,X,,local,,X,,,X,X,amd64,,,,,,"If the userland provides a non-canonical user address for the sysret %rip, some implementations generate a GP fault, however the fault handler would run in kernel mode with the user %gs and %rsp.",
2011-09-28,FreeBSD-SA-11:05.unix,a06534c3c2587eca911a202d556fa656694f0218 5da3eb94fc6c44f333b318c7fd5cd37efea3a7d3,X,X,X,,,,,Easy,local,X,,X,,X,,,,,,,,"Linux compat layer fails to properly generate BSD-compatible sockaddrs for UNIX sockets. The linux_getsockaddr function generates sockaddr_un for domain sockets, this is used among other places in linux_bind() which ends up in uipc_bind(). Now, sockaddr_un has a limited size buffer at the end containing the socket pathname at most of SUNPATHLEN. Linux does not enforce this limitation. The user-given length is set as `sa_len` in the sockaddr as the temporary sockaddr allocation (from the M_SONAME malloc type) used during uipc_bind(). Wihtin the rest of the uipc stack, sockaddr_un have fixed max size and the linux mangled sockaddr_un is copied in fixed-size buffers. An example of this might be uipc_peeraddr() which should be triggerable from the sys_getpeername() syscall on the other end of the socket. This will lead to a kernel heap overflow with possibly arbitrary length (but probably alphanumeric path-like contents). CHERI would stop this by preventing the overflow. Also injecting pointers via the path string would be impossible.",
2010-11-10,FreeBSD-SA-10:09.pseudofs,a0ed3d8546a4f75f27d7e2e188ea679367bc5d39,,,,,,,X,,local,,X,,,,,,,,,,X,"Spurious pseudofs mutex unlock. If NULL page mapping is disabled, this supposedly leads to DoS via NULL pointer dereference. If NULL page mapping is allowed this leads to arbitrary code execution. I do not see how this happens.",
2010-07-13,FreeBSD-SA-10:07.mbuf,d5406806abdc46dbb99934f5001d3b4bf18c8ee4,,,,,,,X,,local,,,,,X,,,,,,,,"Data corruption due to the M_RDONLY flag not being preserved when duplicating an mbuf reference. This leads to the memory being modified for sendfile() external storage pages. CHERI does not help with this because the M_RDONLY flag is not reflected by capability permission bits, however it is conceivable to be able to support this.",
2010-05-27,FreeBSD-SA-10:06.nfsclient,31b99bfe49cfb0820286cb7a3613dbc2f612208c,,,X,,,,,"Possibly, file moved",local,,,X,,,,,,,,X,,"Insufficient userland parameter validation. The parameter fhsize is used to copyin the nfs_args.fh contents, if the fhsize is wrong it will overflow the stack-allocated nfh buffer, overflowing the kernel stack. This may lead to kernel code execution, CHERI stops the overflow.",
2010-01-06,FreeBSD-SA-10:03.zfs,5f99f8897523967aea4a686283be802e11036b69,,,,,,,X,,local,,,,,,X,,,,X,,,ZFS ZIL playback of setattr transaction sets invalid insecure file attributes (0777),
2009-10-02,FreeBSD-SA-09:14.devfs,482acad57332f5ff6f288860c5b7a1e820bddb95,,X,,,,,,,local,,X,,,,,,,X,X,,X,NULL pointer race. Unsure how this is triggered but appears to involve missing initialization of f_vnode.,2009-10-02: User NULL mappings forbidden
2009-10-02,FreeBSD-SA-09:13.pipe,pipe.patch 741b6cf8a565f75b3868bea8a0c4c0e247e23d24,,,,,T,,,,local,,,,,,,,UMA pipe_zone,X,,,,"Race in pipe close() causes use after free. This is well explained in the commit message. In essence knlist_clear may drop the PIPE_MTX, allowing the other end of the pipe to enter pipe close() as well. The pipe_present state is cleared before releasing PIPE_MTX, which would allow the other thread to detect the pipe as fully closed and call uma_zfree on it. The original close() thread will then proceed to use the free'd pipe data.",
2009-06-10,FreeBSD-SA-09:10.ipv6,9a1bde1808c46ddbf781de3cfe4ab990079aa151,,,,,,,X,,local,,,,,,X,,,,X,X,,missin permission check in IPv6 ioctl.,
2009-06-10,FreeBSD-SA-09:09.pipe,9a1bde1808c46ddbf781de3cfe4ab990079aa151,,,,,,,X,,local,,,,X,,,,,,,,,"Integer overflow in pipe causes leak of user or kernel pages. CHERI does not help because the leak occurs by mapping and copying physical pages, which are not protected by capabilities.",
2009-03-23,FreeBSD-SA-09:06.ktimer,3f935cf34295f0bc10b371149c83b8b24366061b,,,X,,,,,,local,,,,,X,,,,,,,,Arbitrary kernel memory write due to missing negative check on timer ID. Leads to buffer overflow of p_itimers->its_timers[]. Subobject bounds would apply if the itimers struct contained any other field. The buffer comes from kmalloc.,
2008-12-23,FreeBSD-SA-08:13.protosw,f0b40b1c97b2efe9f22af5d63ec6c62c55804a43,X,X,,X,,,,,local,,,X,,,,,,,,X,X,"Arbitrary code execution in bluetooth and netgraph sockets due to missing function pointer initialization. CHERI should stop this due to missing tags and permissions on invalid function pointers. This would prevent a call to NULL from being exploited in any way. However this in general should cause a crash, depending on the NULL pointer dereference impact, code exec occurs if NULL pointer mappings are allowed.",
2008-11-24,FreeBSD-SA-08:11.arc4random,8c85a7fb78d9486ad7db6ce44dfa06449d931fd,,,,,,,X,,local,,,,,,X,,,,X,,,randomdev predictable sequence vulnerability,
2008-10-02,FreeBSD-SA-08:10.nd6,29a6d781afe0d924b678a10b2c2195555cbf3ba1,,,,,,,X,,remote,,X,,,,X,,,,,,,neighbour discovery ipv6 algorithm flaw,
2008-09-03,FreeBSD-SA-08:09.icmp6,59ca51adba9254260a817dcac4a816af4f5b83b9,,,,,,,X,,remote,,X,,,,X,,,,,X,,"Panic due to invalid processing of the IPv6 MTU value in ICMP packet. The exact panic trigger is unknown, the patch seems to limit the mtu size reduction to be close to spec. Does not appear to be memory-safety related",
2008-09-03,FreeBSD-SA-08:08.nmount,59ca51adba9254260a817dcac4a816af4f5b83b9,,,X,,,,,,local,kstack,,,,X,,,,,,,,Kernel stack overflow via an error string vulnerability. The stack buffer has a fixed length but it is filled with an arbitrary length VFS option from userspace.,
2008-09-03,FreeBSD-SA-08:07.amd64,8ad85ff260e18e0bf17f67ab941663d141d248e3,,,,,,,X,,local,,,X,,,X,amd64,,,X,,,kernel/user state is mixed due to repeated execution of swapgs when a general protection fault is handled during an interrupt,
2008-02-14,FreeBSD-SA-08:04.ipsec,709dbc33b14011a5969835f1d020adc93138f0b5,,X,,,,,,,remote,,X,,,,,,,,,X,X,NULL pointer dereference in ipsec,
2008-02-14,FreeBSD-SA-08:03.sendfile,1b7089994ced9be5f5defe4fbeba532847829b6f,,,,,,,X,,local,,,,,,X,,,,X,X,,"sendfile fails to check file permission flags and can send write-only files, leading to privilege escalation",
2007-11-29,FreeBSD-SA-07:09.random,9790a3cbd4acf18a684305d39c51b4736287160a,,,,,,,X,,local,,,,,,X,,,,,,,yarrow random algorithm bug allows replay of previous values.,
2007-04-26,FreeBSD-SA-07:03.ipv6,67debc100cac6e37d4599cccb35fa5c15c9502a2 ipv6.patch,,,,,,,X,,remote,,X,,,,X,,,,,,,DoS traffic amplification attack,
2006-12-06,FreeBSD-SA-06:25.kmem,8b0a738288f8e63f247c75ec1d1055b2d9509492,,,X,,,X,,,local,X,,,X,,,,,,,,,"Incorrect signed integer comparison for buffer length triggers kernel buffer overflow on copyout. Depending on the firewire device, the buffer may be coming from kmalloc or from an array embedded in the fw_device structure. The latter case is also impacted by subobject bounds.",
2006-08-23,FreeBSD-SA-06:18.ppp,6aa3bc96a6cb4b46430317eb81d1f7ce055741ec,,,X,,,,,,remote,kmalloc,,,X,X,,,,,,X,,Failure to validate option length for Link Control Protocol of PPP in sppp leads to kernel buffer overflow,
2006-05-31,FreeBSD-SA-06:16.smbfs,72f6a0fa7ae2649befc0ff21477e0f444d8c4e16,,,,,,,X,,local,,,,,,X,,,,X,,,"smbfs fails to sanitize paths correctly, leading to chroot escape",
2006-04-19,FreeBSD-SA-06:14.fpu,2652af563e4dfb232dce805d80565964baa65cdb,,,,,,,X,,local,,,,X,,X,amd64,,,,,,"Some floating point registers are not preserved across context switches (FIP, FOP, FDP). In a CHERI implementation FIP/FDP may have been capabilities.",
2006-03-22,FreeBSD-SA-06:11.ipsec,d16f6f50276f22d892749e99b9ad5f6b7e1d41c8,,,,,,,X,,remote,,,,,,X,,,,X,X,,IPsec replay attack,
2006-03-01,FreeBSD-SA-06:10.nfs,925374d4538beff4ffddc35f8f28ec92949edaff,,X,,,,,,,remote,,X,,,,,,,,,X,X,"NULL pointer dereference due to missing check in NFS server code. I am unsure but this might also be causing an m_copym overflow if slp->ns_reclen is a negative value, due to signed integer confusion.",
2006-02-01,FreeBSD-SA-06:08.sack,tcp_sack.patch,,,,,,,X,,remote,,X,,,,X,,,,,X,,Selective ACK may cause TCP to enter an infinite loop when there is not enough memory to handle the ACK on the sender.,
2006-01-25,FreeBSD-SA-06:07.pf,31f9d10a7771b39009a35c4b36fdbe2797db8e64,,,,,,,X,,remote,,X,,,,X,,,,,X,,"A crafted sequence of fragmented packets may crash the system due to a duble insert into the pf fragment cache, which violates a kernel invariant. pf_fragcache is called by pf_normalize_ip, which make a distinction based on whether the rule is a `scrub fragment xxx` rule. The issue arises when inserting a fragment with a gap with respect to the next fragment in the cache. When this occurs, if there was a gap also with respect to the previous fragment, the current fragment is inserted twice into the cache, causing the invariant violation. This does not seem related to memory safety.",
2006-01-25,FreeBSD-SA-06:06.kmem CVE-2006-0380,e55e5e42767a4d8e045da4d1c82715c64a9967ca,,,X,,,,,Easy,local,X,,,X,,,,,,,,,Buffer overflow in getchanlist via copyout() discloses kernel memory to user.,
2006-01-25,FreeBSD-SA-06:06.kmem CVE-2006-0379,02d4ab93fb7545debdb2a8e9f68bb481e7623e6a,,,,,,,X,Easy,local,,,,X,,,,,,,,,Missing buffer initialization before copyout() discloses uninitialized bytes from the kernel stack. Can not be mitigated by CHERI.,
2006-01-18,FreeBSD-SA-06:05.80211,9238d0aff638719975e1cb21ec9d73a5f85a1711,X,,X,,,X,,Feasible,remote,X,,X,,X,,,,,,X,,"Remote overflow in IEEE802.11 beacon handling. Caused by integer overflow in the beacon, results in the overflow of a kernel stack allocation. It is unclear how many bytes we can overflow the buffer.",
2006-01-11,FreeBSD-SA-06:04.ipfw,9ed97bee65d1de7f1a01b80b7ab41c6adff77415,,X,,,,,,,remote,,X,,,,,,,,,X,X,"In ipfw_chk(), we may send a reject message due to O_REJECT rule. When this happens we need to make sure we are not in the middle of an IP fragmented packet, because in that case we do not have the `ulp` pointer to the upper-layer-protocol header initialized. This is detected via the current offset variable, which indicates the current packet offset in the fragmented packet. The issue arises from the ICMP check on the ulp pointer, which leads to a NULL pointer dereference.",
2005-07-27,FreeBSD-SA-05:19.ipsec,1fcc990954dd1f3d84a0f6c2453bcb263a82506c,,,,,,,X,,remote,,,,X,,X,,,,X,X,,Invalid algorithm used by ipsec,
2005-07-20,FreeBSD-SA-05:17.devfs,02a4be3f74a570c6c427082bca7e131a00e4c512,,,,,,,X,,local,,,,,,X,,,,X,,,devfs missing check allows jailed processes to access some hidden device nodes,
2005-06-29,FreeBSD-SA-05:15.tcp CAN-2005-2068,0a389eab226dfe89be0b831fe454e2cd9a9e9705,,,,,,,X,,remote,,X,,,,X,,,,,X,,Errors in TCP stack SYN handling allows attacker to modify certain TCP options.,
2005-06-29,FreeBSD-SA-05:15.tcp CAN-2005-0356,cf09195ba50c0a676cd8363f5564dc6722f8bdc8,,,,,,,X,,remote,,X,,,,X,,,,,X,,"Errors in TCP stack timestamp processing allow attacker to increment the internal ""recent"" timestamp.",
2005-06-29,FreeBSD-SA-05:13.ipfw,0a389eab226dfe89be0b831fe454e2cd9a9e9705,,,,,,,X,,remote,,,,,,X,,,X,,X,,Locking error in ipfw may lead to incorrect address matching,
2005-05-13,FreeBSD-SA-05:09.htt,f6108b6158c0b1b372ae8afcda21171a67e40933,,,,,,,X,,local,,,,X,,X,x86/amd64,,,X,,,hyper threading information disclosure,
2005-05-06,FreeBSD-SA-05:08.kmem,fd94099ec208321d81b8e997b185156b9af828d4 fe2eee8231bddaae179df741f7df389a96e7afef,,,,,,,X,,local,,,,X,,,,,,,,,Failure to zero fixed-length buffers where variable-length strings are copied may result in kernel memory disclosure. CHERI does not help with this because the buffers are legitimate structure space that fails to be initialized.,
2005-05-06,FreeBSD-SA-05:07.ldt,9b2dc15ca0fb622177f64aec7470545687d11030,,,X,,,,,,local,X,,,X,,,i386,,,,,,"syscall args validation error results in overflowing copyout. Overflows an UMA buffer or a statically allocated array, both will be bounded with CHERI.",
2005-05-06,FreeBSD-SA-05:06.iir,c340af03a0d3f3aadf322426d91bd2dd90062ad9,,,,,,,X,,local,,,,,,X,,,,X,,,invalid filesystem permissions on dev node,
2005-04-15,FreeBSD-SA-05:04.ifconf,baeddd23a09138f7b54dacb7b5208c35ce86b839,,,,,,,X,,local,,,,X,,,,,,,X,,kernel memory disclosure due missing clearing of ifreq.ifr_name to SIOCGIFCONF. CHERI does not help because this involves failed zeroing of inner structure padding.,
2005-04-06,FreeBSD-SA-05:03.amd64,352e3efb7051ec9ea2613f479df7e449f1c6325a,,,,,,,X,,local,,,,,,X,X,,,X,,,Failure to initialize the TSS register leads to privilege escalation as user becomes able to access restricted hardware resources.,
2005-04-04,FreeBSD-SA-05:02.sendfile,89a577e7b418e8029e0ca74c20fd14276cc79e61,,,,,,,?,Feasible,local,X,,,X,,,,,,,X,,"The vnode pager was not notified of the change in size. It is unclear if CHERI would help, given the fact that sendfile operates on physical unmapped pages I believe CHERI doest not catch the bug.",
2004-12-01,FreeBSD-SA-04:17.procfs,ebbf4e4bde2322b38bffad4a30b6d9e09942fc21,X,X,,,,,,Feasible,local,,X,,X,,,,,,,,X,"Unvalidated userspace pointer dereference. procfs_doproccmdline() is supposed to extract argv from a process and make it accessible via procfs. In the function, we copy into the kernel the target process ps_strings structure, then each argument is copied to the kernel via copyin(). However the argv vector itself is not copied to kernel memory via sbuf_copyin, leading to the possibility of a malicious process forging its argv pointer in ps_strings with a crafted kernel pointer or NULL (DoS). Given that the actual string is copied via sbuf_copyin(), that protects against kernel pointer forging within the vector, as such it seems difficult to disclose actual kernel data. Note that the result of sbuf_copyin() is not checked, so it will fail silently if the pointers in argv are weird. The ps_nargvstr is also not validated, which may lead to controlling the loop iteration past ARG_MAX (and incidentally the fix seems vulnerable to an integer overflow in the ARG_MAX comparison, although CHERI does not help there more than it already does).",
2004-10-04,FreeBSD-SA-04:15.syscons,611fe940a3f8e543d2d35ee4e4ac916e0c94f864,,,X,,,,,,local,X,,,X,,,,,,,,,"Missing syscons ioctl input validation, negative coordinates may be used to index into the syscons frame buffer",
2004-06-30,FreeBSD-SA-04:13.linux,97f3bd9e54fd321453cc7e3688541843333b8e05 36db02ff0b16f7e9c9ad41f58c012ddc38cc5e41,?,?,?,,,,,Feasible,local,X,,,,X,,,,X,,,,Missing input validation and copyin in some linux compat ioctl.,
2004-06-07,FreeBSD-SA-04:12.jailroute,rtsock.patch,,,,,,,X,,local,,,,,,X,,,,X,,,Missing jail check,
2004-05-19,FreeBSD-SA-04:11.msync,827f9222d6beb5494a0fd38ff7b3d4c11d9003aa,,,,,,,X,,local,,,,,,X,,,,,,,Block cache inconsistency bug may prevent changes to be committed to disk,
2004-03-29,FreeBSD-SA-04:06.ipv6,a5d1aae31a3f8bac611c91cfff0f4fe4e6c109ca,X,X,,,,,,,local,,X,,X,,,,,,,X,,"Access to IPv6 user-provided sockval and socklen without copyin. Note that the sockval argument is an user-provided pointer that is accessed without validation. This seems particularly bad as the sockval is cast to different types in ip6_setpktoption(). The buffer is always used there only to read from, therefore a forged pointer from the user gives an arbitrary kernel memory read primitive, which in some cases may lead to leaking capabilities, for example in6_pktinfo is large enough (if it was not defeated by pointer integrity). The getsockopt() path is not affected as there is a copyout there. Bounds checking here probably does not help much because lengths seem to be enforced decently already but I may be wrong for some odd corner case.",
2004-03-02,FreeBSD-SA-04:04.tcp,12e2e970515339729eccebdc751afb97fa0af6fa,,,,,,,X,,remote,,X,,,,X,,,,,X,,TCP reassembly queue leads to mbuf exhaustion,
2004-02-25,FreeBSD-SA-04:03.jail,57f22bd4afcdf114d36431cf485a0a73c2c2d79f,,,,,,,X,,local,,,,,,X,,,,X,,,Missing check in jail_attach,
2004-02-05,FreeBSD-SA-04:02.shmat,b00a3c85dac8a3429a32782735dd697746f31302,,,,,T,,T,Feasible,local,,,,,X,,,X,,,,,"It may be possible to make a shared memory segment reference unallocated kernel memory, which leads to badness if reused. Not sure if temporal safety would help",
2003-10-03,FreeBSD-SA-03:17.procfs,8b7358ca435297c386e8005a77868308bb124e1d,,,X,,,,,Maybe feasible,local,X,,,X,,,,,,,,,Kernel stack leak in procfs via uiomove. uio_offset unchecked when indexing into kernel memory buffers. This also affects leaking stack via overflow read of an sbuf. ,
2003-10-02,FreeBSD-SA-03:16.filedesc,filedesc.patch,,,,,T,,T,Feasible,local,,X,,,,,,"X UMA Files zone, filedesc table",,,,,filedesc reference count wrongly handled in readv. Can lead to premature free of a file struct and related UaF. CHERI temporal safety may help,
2003-09-23,FreeBSD-SA-03:14.arp,fedf1d01a20434d2392f16105c85d5f1f33b0839,,,,,,,X,,remote,,X,,,,X,,,,,X,,ARP cache excess size leads to memory exhaustion,
2003-08-10,FreeBSD-SA-03:10.ibcs2,e059b0f0164394576d692cbcc9fa7ae4c0b4281c,,,X,,,,,,local,X,,,X,,,i386,,,,,,Kernel stack structure overflow via copyout leaks kernel stack to userland. NOTE: Would be dangerous on a hybrid kernel because kstack may contain kernel capabilities.,
2003-08-10,FreeBSD-SA-03:09.signal,007e25d95aae1b0d151b33c5c7ac87a097ac6c92 41b3077a6c8c6a258c45f6ab00c3df35bb5184dc,,,X,,,X,,Feasible,local,X,X,,,X,,,,,,,,Without INVARIANTS this gives a write primitive on kernel memory via SIGADDSET (I believe). This should be limited in the way it can corrupt memory because the overflowed signo is used both as an index in the sigset and to compute the bit to flip in the sigset word. Subobject bounds on td_siglist would further stop corruption of the thread struct.,
2003-02-24,FreeBSD-SA-03:03.syncookies,a432399c5682a3d2b91b6801b94032cdce1a1330,,,,,,,X,,remote,,,,,,X,,,,X,X,,SYN cookie secret is too short,
2003-01-07,FreeBSD-SA-02:44.filedesc,f0c093284d4f7194f359d79031d39ee661714057 fpathconf.patch,,,,,?,,T,Feasible,local,,X,,,,,,"X UMA Files zone, filedescent table ",,X,,,"filedesc reference count wrongly incremented can lead to wrapping and free() of file descriptor, leading to erroneous reuse. CHERI kernel temporal safety may help by avoiding reallocation of the same file struct and garbage collecting the dangling capabilities.",
2002-08-19,FreeBSD-SA-02:38.signed-error,82d9ad331ac0a07c584b40ac3fb32498467dd9a5 5b770403b539801d3a313a78da248bf33b292b9e,,,X,,,,,,local,X,,,X,,,,,,,,,Signed overflow due to missing lenght checks in syscalls can cause copyout of kernel memory.,
2002-08-05,FreeBSD-SA-02:37.kqueue,ea4c8f8ca1e0c1d0ec872dc2e90ae97df5ccbc2c,,X,,,,,,Feasible,local,,X,,,,,,,,,,X,NULL pointer dereference (via SLIST_INSERT) in pipe_kqfilter,
2002-08-05,FreeBSD-SA-02:35.ffs,ffs.patch 8680d6985f7e96c0a02896257ed310c2ac88089d 8f42fb8fc9f98f98f7c005ddca17b901c39cbbeb,,,,,,,X,,local,,,,,,,i386/alpha,,,,,,"Resolving the commit is uncertain. This seems related to ffs_oldfscompat_read, where the maxfilesize check has been moved. The patch shows the same fix in ffs_mountfs. The bug seems to allow FS corruption or arbitrary RW on files. From the patch, it seems that previously vm_pindex_t is only 32bit wide and a larger file can not be backed by vm_object nicely. I'm not sure what happens when or where this overflows. The exact mechanism is unclear so mark as CHERI does not help but this is probably memory-safety related.",
2002-07-12,FreeBSD-SA-02:30.ktrace,ktrace.patch,,,,,,,X,,local,,,,,,X,,,,X,,,"Local users are mistakenly allowed to ktrace privileged processes, leading to privilege escalation.",
2002-05-29,FreeBSD-SA-02:26.accept,e1f1827f98282d9d78aae61bfebd23646abf4071,,,,,,,X,,remote,,X,,,,X,,,,,X,,Missing queue draining,
2002-04-22,FreeBSD-SA-02:23.stdio,e983a3762bdd887b8591e44de04182937e7a5d9c,,,,,,,X,,local,,,,,,X,,,,X,,,File descriptors for sUID executable's stdin/out/err are not always reserved.,
2002-04-18,FreeBSD-SA-02:22.mmap,8c5dffe8cafee8addbc1229902ebba5b7d1f62a6,,X,,,,,,,local,,X,,,,,,,,,,X,NULL pointer dereference due to missing check in vm_map.c,
2002-04-17,FreeBSD-SA-02:21.tcpip,e3f406b3c1f506c48f09fed9dc1588172a655465,,,,,,,X,,remote,,X,,,,X,,,,,X,,Reference count decrement error leads to memory leak via ICMP echo reply message.,
2002-04-16,FreeBSD-SA-02:20.syncache (duplicate SYN),0cab7c4b086b1d81ec4f3d5a1fc2a06dbb35a746,,,,,?,,T,,remote,,,,,,,,X,,,X,,"Access to stale syncache pointer may cause a crash. The syncache sc structure holds a pointer to the inpcb of the socket that created it. If the socket was somehow released and a new socket created for the same endpoint, the old pointer from the syncache is not updated when receving a duplicate SYN, instead the old pointer is left unchanged. This is a use after free. CHERI might help if the old inpcb is quarantined or revoked. The impact of stale socket data is unclear.",
2002-04-16,FreeBSD-SA-02:20.syncache (syncookie accept),cc3e7eecb1b1f969de96f82283e0a193ed58123b,,X,,,,,,,remote,,X,,,,,,,,,X,X,"Access to stale syncache pointer may cause a crash. The syncache sc structure holds a pointer to the inpcb. The pointer is uninitialized, and leads to NULL pointer dereference. CHERI helps in the absence of NULL mapping mitigations.",
2002-02-06,FreeBSD-SA-02:09.fstatfs,10cc6dff87ddac48c2342661ef47b0e156222243,,X,,,,,,Feasible,local,,X,,,,,,,X,,,X,Kernel panic from NULL+offset pointer dereference,
2002-01-24,FreeBSD-SA-02:08.exec,9ca45e813c21c73c7c96121963a378811a4e5039,,,,,,,X,,local,,,,,,X,,,X,X,,,Race in attaching debug hooks to setUID binary on exec,
2001-08-17,FreeBSD-SA-01:53.ipfw,9f81cc840b11e57527a75083c4170734f749729e,,,,,,,X,,remote,,,,,,X,,,,X,X,,Flaw in ipfw causes erroneous matching in p2p interfaces.,
2001-08-06,FreeBSD-SA-01:52.fragment,690a6055ffec3b387c4a8412fbf0e975df041bc5,,,,,,,X,,remote,,X,,,,X,,,,,X,,DoS due to limitation of reassembly queues,
2001-07-10,FreeBSD-SA-01:42.signal,333ea48563af190b8265eccbfeddc32b64fa41e0,,,,,,,X,Feasible,local,,,,,,X,,,,X,,,Improperly share signal handlers on exec. Potentially affects CHERI as an executable capability might be leaked to another address space (i.e. the signal handler pointer called).,
2001-05-02,FreeBSD-SA-01:39.tcp-isn,f0a04f3f51485131962ee392decaedefe989018c,,,,,,,X,,remote,,,,,,X,,,,X,X,,TCP sequence number PRNG statistical analysis. Result into spoofing,
2001-04-16,FreeBSD-SA-01:32.ipfilter,ipfilter.patch,,,,,,,X,,remote,,,,,,X,,,,,X,,IPfilter rule bypass,
2001-03-22,FreeBSD-SA-01:30.ufs-ext2fs,91cc89dd77c2fc5dc25b55adea1779ddd18e719e,,,,,,,X,,local,,,,X,,X,,,X,,,,I/O block zeroing bypass can lead to restricted file disclosure,
2001-01-23,FreeBSD-SA-01:08.ipfw,65450f2f77f82c5083ecd137a9c02767423cdf13,,,,,,,X,,remote,,,,,,X,,,,,,,"Flag masking in TCP packet, ipfw rule bypass",
2000-12-18,FreeBSD-SA-00:77.procfs (1),ab3240e1987eced9159e253ab997d8afe4e54995,,,,,,,X,,local,,,,,,X,,,,X,,,"Insufficient access control on /proc/<pid>/{mem,ctl} allow unprivileged user to gain access to the procfs nodes (the trigger is explained well in the advisory).",
2000-12-18,FreeBSD-SA-00:77.procfs (2),ab3240e1987eced9159e253ab997d8afe4e54995,,,,,,,X,,local,,X,,,,X,,,,,,,DoS due to logic error causes infinite loop when a process maps own /proc/<pid>/mem.,
2000-12-18,FreeBSD-SA-00:77.procfs (3),ab3240e1987eced9159e253ab997d8afe4e54995,,,X,,,,,Feasible,local,stack,,,,stack,,,,,,,,Kernel buffer overflow in procfs_dostatus(). A stack-allocated buffer may be overflowed when a long jail pr_name value is set. This should be stopped by CHERI.,
2000-10-06,FreeBSD-SA-00:52.tcp-iss,be515d91ad5712504fd074b5754f4c996fbdf00a,,,,,,,X,,remote,,,,,,X,,,,,X,,"TCP uses weak initial sequence numbers, allowing an attacker to spoof the handshake and send data into the stream. This is not related to memory safety.",
2000-08-28,FreeBSD-SA-00:42.linux,03567510a805f30de80fff8244292ad0ffa923e0,X,,X,,,,,"Hard, ancient linux compat",local,usr stack,,,,usr stack,,,,,,,,"The stackgap code was terrible. The spare stack space between the user stack and PS_STRINGS (which has at least SPARE_USRSPACE bytes) is used to hold a temporary path constructed for the linux compat layer ""shadow"" filesystem. This was done without bounds checking, so long pathnames can overflow the stack allocation. The advisory claims this is a kernel stack overflow however it looks to me that the user stack is being trashed here, also the direction of the overflow is towards the bottom of the stack, where unmapped memory should be, so this would trash ps_strings at most? Either way CHERI should catch the overflow with the stack capability. The code would have required manual changes anyway due to the stackgap pointer provenance, which likely would have uncovered the issue.",
2000-08-28,FreeBSD-SA-00:41.elf,25ead034629f19beba8ce1d70becd28d28805a55,,,,,,,X,"Hard, depends on pmap impl",local,,X,,,,,,,,,,,"imgact_capability in ELF loader may catch it but if the ELF phdr is malformed, the reservation will be malformed and still lead to a larger-than-file pmap req. I believe CHERI would not have caught this if vm_map_find() was used, as it would have attempted to return a new reservation for the page, regardless of the imgact capability.",
2000-06-19,FreeBSD-SA-00:23.ip-options,707d00a304a4c59dece848bc1d2f3b676097cc42,,,X,,,,,Feasible,remote,X,X,,,,,,,,,X,,mbuf m_data accessed via mtod is bounded,
2000-05-23,FreeBSD-SA-00:19.semconfig,b423446cc08f33e22a2009fdcce1656bc8d3d5a2 86c25021825c263d08e45902c95edbd7976f1398,,,,,,,X,,local,,X,,,,X,,,,,,,"An undocumented system call was erroneusly exposed to unprivileged users, allowing a local attacker to hang all processes on exit(). This causes a local DoS, unrelated to memory safety as it is an access-control issue. This occurs via the semconfig() syscall.",
2000-01-24,FreeBSD-SA-00:02.procfs,5e2664428ca6992976b23992aa33e667fd73b229,,,,,,,X,,local,,,,,,X,,,,X,,,setuid programs may be abused to access privileged procfs files via sdin/out/err. Not clear how this is triggered but not memory-safety related.,