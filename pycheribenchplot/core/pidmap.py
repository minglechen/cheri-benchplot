import json
import io
import typing
from pathlib import Path

import pandas as pd
import numpy as np

from .dataset import DatasetID, DataField, StrField, IndexField
from .json import JSONDataSetContainer


class PidMapDataset(JSONDataSetContainer):
    """
    JSON output generated by the --libxo option of the ps command
    Currently we only support a subset of the output values
    """
    dataset_id = DatasetID.PIDMAP
    fields = [IndexField("pid", dtype=int), IndexField("tid", dtype=int), StrField("command"), StrField("thread_name")]

    def raw_fields(self, include_derived=False):
        return PidMapDataset.fields

    def load(self, path: Path):
        with open(path, "r") as fd:
            raw_data = json.load(fd)
        data_map = raw_data["procstat"]["threads"]
        # normalize records in the json first
        data = list(data_map.values())
        for proc_desc in data:
            proc_desc["threads"] = list(proc_desc["threads"].values())
        df = pd.json_normalize(data, "threads", ["process_id", "command"])
        df.rename(columns={"process_id": "pid", "thread_id": "tid"}, inplace=True)
        df["__dataset_id"] = self.benchmark.uuid
        self._internalize_json(df)

    def resolve_user_binaries(self, dataset_id) -> pd.DataFrame:
        df = self.df.xs(dataset_id)
        P_KPROC_MASK = 0x4
        user_commands = (df["flags"] & P_KPROC_MASK) == 0

        def resolve_path(cmd):
            target_path = Path(cmd)
            if target_path.is_absolute():
                return self.benchmark.rootfs / target_path.relative_to("/")
            else:
                # attempt to locate file in /bin /usr/bin /usr/sbin
                dollarpath = [Path("bin"), Path("usr/bin"), Path("usr/sbin")]
                for path in dollarpath:
                    candidate = self.benchmark.rootfs / path / target_path
                    if candidate.exists():
                        return candidate
            return None

        result_df = df.copy()
        result_df["command"] = df["command"].map(resolve_path)
        return result_df[~result_df["command"].isna()]

    def output_file(self):
        return super().output_file().with_suffix(".json")

    async def run_post_benchmark(self):
        """
        Post-benchmark hook to extract PID mappings.
        Note: we also use the command history from the benchmark runner to resolve any
        extra processes we have been running and that have since terminated.
        """
        self.logger.info("Extract system PIDs")
        pid_raw_data = io.StringIO()
        await self.benchmark.run_cmd("procstat", ["-a", "-t", "--libxo", "json"], outfile=pid_raw_data)
        # Append the PIDs for all processes executed by the benchmark to the pid map
        pid_json = json.loads(pid_raw_data.getvalue())
        proc_map = pid_json["procstat"]["threads"]
        for history_entry in self.benchmark.command_history.values():
            entry = {
                str(history_entry.pid): {
                    "process_id": history_entry.pid,
                    "command": str(history_entry.cmd),
                    # We do not have thread info for these, should really use KTR instead
                    "threads": {
                        "-1": {
                            "thread_id": "-1",
                            "thread_name": "-"
                        }
                    }
                }
            }
            proc_map.update(entry)
        with open(self.output_file(), "w+") as pid_fd:
            json.dump(pid_json, pid_fd)
